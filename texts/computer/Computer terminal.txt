A computer terminal is an electronic or electromechanical hardware device that is used for entering data into, and displaying data from, a computer or a computing system. Early terminals were inexpensive devices but very slow compared to punched cards or paper tape for input, but as the technology improved and video displays were introduced, terminals pushed these older forms of interaction from the industry. A related development was timesharing systems, which evolved in parallel and made up for any inefficiencies of the user's typing ability with the ability to support multiple users on the same machine, each at their own terminal.
The function of a terminal is confined to display and input of data; a device with significant local programmable data processing capability may be called a "smart terminal" or fat client. A terminal that depends on the host computer for its processing power is called a "dumb terminal" or thin client. A personal computer can run terminal emulator software that replicates the function of a terminal, sometimes allowing concurrent use of local programs and access to a distant terminal host system.




The terminal of the first working programmable, fully automatic digital  Turing-complete computer, the Z3, had a keyboard and a row of lamps to show results.



Early user terminals connected to computers were electromechanical teleprinters/teletypewriters (TeleTYpewriter, TTY), such as the Teletype Model 33 ASR, originally used for telegraphy or the Friden Flexowriter. Later printing terminals such as the DECwriter were developed. However printing terminals were limited by the speed at which paper could be printed, and for interactive use the paper record was unnecessary.
By the early 1970s, many in the computer industry realized that an affordable video data entry terminal could supplant the ubiquitous punched cards and permit new uses for computers that would be more interactive. The problem was that the amount of memory needed to store the information on a page of text was comparable to the memory in low end minicomputers then in use. Displaying the information at video speeds was also a challenge and the necessary control logic took up a rack worth of pre-integrated circuit electronics. One company announced plans to build a video terminal for $15,000 and attracted a large backlog of orders, but folded when their engineering plans, which included fabricating their own ICs, proved too ambitious. Another approach involved the use of the storage tube, a specialized CRT developed by Tektronix that retained information written on it without the need to refresh.
The Datapoint 3300 from Computer Terminal Corporation was announced in 1967 and shipped in 1969, making it one of the earliest stand-alone display-based terminals. It solved the memory space issue mentioned above by using a digital shift-register design, and using only 72 columns rather than the later more common choice of 80.



Early video computer displays were sometimes nicknamed "Glass TTYs" ("glass Teletypes") or "Visual Display Units" (VDUs), and used individual logic gates, with no CPU or very primitive LSI chips, yet quickly became extremely popular Input-Output devices on many different types of computer system once several suppliers gravitated to a set of common standards:
ASCII character set (rather than, say, EBCDIC or anything specific to one company), but early/economy models often supported only capital letters (such as the original ADM-3, the Data General model 6052 - which could be upgraded to a 6053 with a lower-case character ROM - and the Heathkit H9)
RS-232 serial ports (25-pin, ready to connect to a modem, yet some manufacturer-specific pin usage extended the standard, e.g. for use with 20-mA current loops)
24 lines (or possibly 25 - sometimes a special status line) of 80 characters of text (sometimes with two character width settings).
Some type of blinking cursor that can be positioned (with arrow keys and/or "home" and other direct cursor address setting codes).
Implementation of at least 3 control codes: Carriage Return (Ctrl-M), Line-Feed (Ctrl-J), and Bell (Ctrl-G), but usually many more, such as Escape sequences to provide underlining, dim and/or reverse-video character highlighting, and especially to clear the display and position the cursor.
Starting with the Datapoint 3300 in 1969, by the late 1970s and early 1980s, there were dozens of manufacturers of terminals, including Lear-Siegler, Data General, DEC, Hazeltine Corporation, Heath/Zenith, Hewlett Packard, IBM, Televideo, and Wyse, many of which had incompatible command sequences (although many used the early ADM-3 as a starting point).
The great variations in the control codes beteween makers gave rise to software that identified and grouped terminal types so the system software would correctly display input forms using the appropriate control codes; In Unix-like systems the termcap or terminfo files, the stty utility, and the TERM environment variable would be used; in Data General's Business BASIC software, for example, at login-time a sequence of codes were sent to the terminal to try to read the cursor's position or the 25th line's contents using a sequence of different manufacturer's control code sequences, and the terminal-generated response would determine a single-digit number (such as 6 for Data General Dasher terminals, 4 for ADM 3A/5/11/12 terminals, 0 or 2 for TTY's with no special features) that would be available to programs to say which set of codes to use.



An "intelligent" terminal does its own processing, usually implying a microprocessor is built in, but not all terminals with microprocessors did any real processing of input: the main computer to which it was attached would have to respond quickly to each keystroke. The term "intelligent" in this context dates from 1969.
Notable examples include the IBM 2250 and IBM 2260, predecessors to the IBM 3270 and introduced with System/360 in 1964.
From the introduction of the IBM 3270, and the DEC VT100 (1978), the user and programmer could notice significant advantages in VDU technology improvements, yet not all programmers used the features of the new terminals (backward compatibility in the VT100 and later Televideo terminals, for example, with "dumb terminals" allowed programmers to continue to use older software).
Some dumb terminals had been able to respond to a few escape sequences without needing microprocessors: they used multiple printed circuit boards with many Integrated Circuits; the single factor that classed a terminal as "intelligent" was its ability to process user-input within the terminal not interrupting the main computer at each keystroke and send a block of data at a time (for example: when the user has finished a whole field or form). Most terminals in the early 1980s, such as ADM-3A, TVI912, Data General D2, DEC VT52, despite the introduction of ANSI terminals in 1978, were essentially "dumb" terminals, although some of them (such as the later ADM and TVI models) did have a primitive block-send capability.
The advance in microprocessors and lower memory costs made it possible for the terminal to handle editing operations such as inserting characters within a field that may have previously required a full screen-full of characters to be re-sent from the computer, possibly over a slow modem line. Around the mid 1980s intelligent terminals, costing less that most dumb terminals would have a few years earlier, could provide enough user-friendly local editing of data and send the completed form to the main computer. Providing even more processing possibilities, workstations like the Televideo TS-800 could run CP/M-86, blurring the distinction between terminal and Personal Computer.
Another of the motivations for development of the microprocessor was to simplify and reduce the electronics required in a terminal. That also made it practicable to load several "personalities" into a single terminal, so a Qume QVT-102 could emulate many popular terminals of the day, and so be sold into organizations that did not wish to make any software changes. Frequently emulated terminal types included:
Lear Siegler ADM-3A and later models
Televideo 910 to 950 (these models copied ADM3 codes and added several of their own, eventually being copied by Qume and others)
Digital Equipment Corporation VT52 and VT100
Data General D1 to D3 and especially D200 and D210
Hazeltine Corporation H1500
Tektronix 4014
Wyse W50, W60 and W99
The ANSI X3.64 escape code standard produced uniformity to some extent, but significant differences remained (for example, the VT100, Heathkit H19 in ANSI mode, Televideo 970, Data General D460, and Qume QVT-108 terminals all followed the ANSI standard, yet differences might exist of codes from function keys, what character attributes were available, block-sending of fields within forms, "foreign" character facilities, and handling of printers connected to the back of the screen).
Most terminals were connected to minicomputers or mainframe computers and often had a green or amber screen. Typically terminals communicate with the computer via a serial port via a null modem cable, often using an EIA RS-232 or RS-422 or RS-423 or a current loop serial interface. IBM systems communicated over a coaxial cable using IBM's SNA protocol, but for many DEC, Data General and NCR (and so on) computers there were many visual display suppliers competing against the computer manufacturer for terminals to expand the systems. In fact, the instruction design for the Intel 8008 was originally conceived at Computer Terminal Corporation as the processor for the Datapoint 2200.



While early IBM PCs had single color green screens, these screens were not terminals. The screen of a PC did not contain any character generation hardware; all video signals and video formatting were generated by the video display card in the PC, or (in most graphics modes) by the CPU and software. An IBM PC monitor, whether it was the green monochrome display or the 16-color display, was technically much more similar to an analog TV set (without a tuner) than to a terminal. With suitable software a PC could, however, emulate a terminal, and in that capacity it could be connected to a mainframe or minicomputer. The Data General One could be booted into terminal emulator mode from its ROM. Eventually microprocessor-based personal computers greatly reduced the market demand for conventional terminals.
In the 1990s especially, "thin clients" and X terminals have combined economical local processing power with central, shared computer facilities to retain some of the advantages of terminals over personal computers:
Today, most PC telnet clients provide emulation of the most common terminal, the DEC VT100, using the ANSI escape code standard X3.64, or could run as X terminals using software such as Cygwin/X under Microsoft Windows or X.Org Server software under Linux.
Since the advent and subsequent popularization of the personal computer, few genuine hardware terminals are used to interface with computers today. Using the monitor and keyboard, modern operating systems like Linux and the BSD derivatives feature virtual consoles, which are mostly independent from the hardware used.
When using a graphical user interface (or GUI) like the X Window System, one's display is typically occupied by a collection of windows associated with various applications, rather than a single stream of text associated with a single process. In this case, one may use a terminal emulator application within the windowing environment. This arrangement permits terminal-like interaction with the computer (for running a command line interpreter, for example) without the need for a physical terminal device; it can even allow the running of multiple terminal emulators on the same device.







A text terminal, or often just terminal (sometimes text console) is a serial computer interface for text entry and display. Information is presented as an array of pre-selected formed characters. When such devices use a video display such as a cathode-ray tube, they are called a "video display unit" or "visual display unit" (VDU) or "video display terminal" (VDT).
The System console is a text terminal used to operate a computer. Modern computers have a built-in keyboard and display for the console. Some Unix-like operating systems such as Linux and FreeBSD have virtual consoles to provide several text terminals on a single computer.
The fundamental type of application running on a text terminal is a command line interpreter or shell, which prompts for commands from the user and executes each command after a press of Enter. This includes Unix shells and some interactive programming environments. In a shell, most of the commands are small applications themselves.
Another important application type is that of the text editor. A text editor occupies the full area of display, displays one or more text documents, and allows the user to edit the documents. The text editor has, for many uses, been replaced by the word processor, which usually provides rich formatting features that the text editor lacks. The first word processors used text to communicate the structure of the document, but later word processors operate in a graphical environment and provide a WYSIWYG simulation of the formatted output.
Programs such as Telix and Minicom control a modem and the local terminal to let the user interact with remote servers. On the Internet, telnet and ssh work similarly.
In the simplest form, a text terminal is like a file. Writing to the file displays the text and reading from the file produces what the user enters. In unix-like operating systems, there are several character special files that correspond to available text terminals. For other operations, there are special escape sequences, control characters and termios functions that a program can use, most easily via a library such as ncurses. For more complex operations, the programs can use terminal specific ioctl system calls. For an application, the simplest way to use a terminal is to simply write and read text strings to and from it sequentially. The output text is scrolled, so that only the last several lines (typically 24) are visible. Unix systems typically buffer the input text until the Enter key is pressed, so the application receives a ready string of text. In this mode, the application need not know much about the terminal. For many interactive applications this is not sufficient. One of the common enhancements is command line editing (assisted with such libraries as readline); it also may give access to command history. This is very helpful for various interactive command line interpreters.
Even more advanced interactivity is provided with full-screen applications. Those applications completely control the screen layout; also they respond to key-pressing immediately. This mode is very useful for text editors, file managers and web browsers. In addition, such programs control the color and brightness of text on the screen, and decorate it with underline, blinking and special characters (e.g. box drawing characters). To achieve all this, the application must deal not only with plain text strings, but also with control characters and escape sequences, which allow to move cursor to an arbitrary position, to clear portions of the screen, change colors and display special characters, and also respond to function keys. The great problem here is that there are so many different terminals and terminal emulators, each with its own set of escape sequences. In order to overcome this, special libraries (such as curses) have been created, together with terminal description databases, such as Termcap and Terminfo.



Dumb terminals are those that can interpret a limited number of control codes (CR, LF, etc.) but do not have the ability to process special escape sequences that perform functions such as clearing a line, clearing the screen, or controlling cursor position. In this context dumb terminals are sometimes dubbed glass Teletypes, for they essentially have the same limited functionality as does a mechanical Teletype. This type of dumb terminal is still supported on modern Unix-like systems by setting the environment variable TERM to dumb. Smart or intelligent terminals are those that also have the ability to process escape sequences, in particular the VT52, VT100 or ANSI escape sequences.



A graphical terminal can display images as well as text. Graphical terminals are divided into vector-mode terminals, and raster mode.
A vector-mode display directly draws lines on the face of a cathode-ray tube under control of the host computer system. The lines are continuously formed, but since the speed of electronics is limited, the number of concurrent lines that can be displayed at one time is limited. Vector-mode displays were historically important but are no longer used. Practically all modern graphic displays are raster-mode, descended from the picture scanning techniques used for television, in which the visual elements are a rectangular array of pixels. Since the raster image is only perceptible to the human eye as a whole for a very short time, the raster must be refreshed many times per second to give the appearance of a persistent display. The electronic demands of refreshing display memory meant that graphic terminals were developed much later than text terminals, and initially cost much more.
Most terminals today are graphical, that is, they can show images on the screen. The modern term for graphical terminal is "thin client". A thin client typically uses a protocol like X11 for Unix-terminals, or RDP for Microsoft Windows. The bandwidth needed depends on the protocol used, the resolution, and the color depth.
Modern graphic terminals allow display of images in color, and of text in varying sizes, colors, and fonts (type faces).
In the early 1990s an industry consortium attempted to define a standard, AlphaWindows, that would allow a single CRT screen to implement multiple windows, each of which was to behave as a distinct terminal. Unfortunately like I2O this suffered from being run as a closed standard: non-members were unable to obtain even minimal information and there was no realistic way a small company or independent developer could join the consortium. Possibly because of this the standard disappeared without trace.



A terminal emulator is a piece of software that emulates a text terminal. In the past, before the widespread use of local area networking and broadband internet access, many computers would use a serial access program to communicate with other computers via telephone line or serial device.
When the first Macintosh was released, a program called MacTerminal was used to communicate with many computers, including the IBM PC.
Dec Terminal was one of the first terminal programs for the popular Altair.
The Win32 console on Windows does not emulate a physical terminal that supports escape sequences so SSH and Telnet programs (for logging in textually to remote computers) for Windows, including the Telnet program bundled with some versions of Windows, often incorporate their own code to process escape sequences. The terminal emulators on most Unix-like systems, such as, for example, xterm and Terminal, emulate physical terminals that support escape sequences



Terminals can operate in various modes, relating to when they send input typed by the user on the keyboard to the receiving system (whatever that may be):
Character mode (a.k.a. character-at-a-time mode): In this mode, typed input is sent immediately to the receiving system.
Line mode (a.k.a. line-at-a-time mode): In this mode, the terminal provides a local line editing function, and sends an entire input line, after it has been locally edited, when the user presses a return key. A so-called "line mode terminal" operates solely in this mode.
Block mode (a.k.a. screen-at-a-time mode): In this mode, the terminal provides a local full-screen data function. The user can enter input into multiple fields in a form on the screen (defined to the terminal by the receiving system), moving the cursor around the screen using keys such as Tab   and the arrow keys and performing editing functions locally using insert, delete,   Backspace and so forth. The terminal sends only the completed form, consisting of all the data entered on the screen, to the receiving system when the user presses an   Enter key.
There is a distinction between the return and the   Enter keys. In some multiple-mode terminals, that can switch between modes, pressing the   Enter key when not in block mode does not do the same thing as pressing the return key. Whilst the return key will cause an input line to be sent to the host in line-at-a-time mode, the   Enter key will rather cause the terminal to transmit the contents of the character row where the cursor is currently positioned to the host, host-issued prompts and all.
Different computer operating systems require different degrees of mode support when terminals are used as computer terminals. The POSIX terminal interface, as provided by Unix and POSIX-compliant operating systems, does not accommodate block-mode terminals at all, and only rarely requires the terminal itself to be in line-at-a-time mode, since the operating system is required to provide canonical input mode, where the terminal device driver in the operating system emulates local echo in the terminal, and performs line editing functions at the host end. Most usually, and especially so that the host system can support non-canonical input mode, terminals for POSIX-compliant systems are always in character-at-a-time mode. In contrast, IBM 3270 terminals connected to MVS systems are always required to be in block mode.


