A computer program is, fundamentally, the use of instructions executed by a computer. By default, instructions are executed in sequence as they appear in the program, but the exception to this rule is the execution of branch or jump instructions that (may) cause the computer to begin execution of a different part of the program than the next instruction, thus "jumping" (or "branching") from one part of the program to another. Branch instructions are used to implement control flow constructs such as conditionals or loops. A branch instruction can be either an unconditional branch, which always results in branching, or a conditional branch, which may or may not cause branching depending on some condition.



The term branch can be used when referring to programs in high level languages as well as program written in machine code or assembly language. In high-level programming languages, branches usually take the form of conditional statements of various forms that encapsulate the instruction sequence that will be executed if the conditions are satisfied. Unconditional branch instructions such as GOTO are used to unconditionally "jump" to (begin execution of) a different instruction sequence.
Machine level branch instructions are sometimes called jump instructions. Machine level jump instructions typically have unconditional and conditional forms where the latter may be taken or not taken depending on some condition. The truthness of this condition is typically evaluated and temporarily stored by some previous instruction (though not necessarily the one immediately before) and then used such as in jump if overflow-flag set. This temporary information is often stored in a flag register but may also be located elsewhere. There are also machines (or particular instructions) where the condition may be checked by the jump instruction itself, such as branch <label> if register X negative. When a branch is taken, the next instruction executed is defined by the argument to the jump instruction; when not taken, the next instruction executed is the instruction immediately following the jump instruction in memory so that the flow of control is unchanged.
Depending on computer architecture, the assembly language mnemonic for a jump instruction is typically some shortened form of the word jump or the word branch, often along with other informative letters (or an extra parameter) representing the condition. Sometimes other details are included as well, such as the range of the jump (the offset size) or a special addressing mode that should be used to locate the actual effective offset.



This table lists the machine level branch/jump instructions found in several well-known architectures:
* x86, the PDP-11, VAX, and some others, set the carry-flag to signal borrow and clear the carry-flag to signal no borrow. ARM, 6502, the PIC, and some others, do the opposite for subtractive operations. This inverted function of the carry flag for certain instructions is marked by (*), that is, borrow=not carry in some parts of the table, but if not otherwise noted, borrow carry. However, carry on additive operations are handled the same way by most architectures.



To achieve high performance, modern processors are pipelined: they consist of multiple parts that each partially process an instruction, feed their results to the next stage in the pipeline, and start working on the next instruction in the program. This requires knowing which instruction is going to be executed next, and (conditional) branch instructions make it impossible to know this in general, thus potentially causing stalls where the pipeline has to be restarted on a different part of the program.
Two techniques alleviate this situation. The first is branch prediction, which is implemented as part of modern processors. The processor attempts to guess the outcome of the conditional test and starts executing the branch that it thinks is going to be taken. The other technique is to write programs without branches, or with fewer branches, typically using bitwise operations instead.


